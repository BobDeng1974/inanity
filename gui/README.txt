Концепция пользовательского интерфейса.

Пользовательский интерфейс состоит из элементов (Element) - аналог controls. Интерфейс предполагается плоским, поддерживающим прозрачность (то есть в принципе может быть прозрачным). Система координат - декартова, начало координат - слева вверху, единица измерения - пикселы или экраны. Все элементы имеют положение (координаты левого верхнего угла) и размер (ширина и высота ограничивающего прямоугольника). Все элементы обязаны уметь быть любого положительного размера (по крайней мере корректно обрабатывать эту ситуацию). В плане рисования элементы не обязаны держать себя в заданных рамках положения и размера, но в плане обработки мыши - должны. Правда, элементы не обязаны занимать весь ограничивающий прямоугольник, они могут быть любой формы, и за это отвечает метод Element::IsPositionInto.
Есть контейнерные элементы - элементы, которые содержат в себе другие элементы. Обычно за весь экран отвечает один корневой элемент, у которого есть дочерние элементы, и так далее. События мыши также получает корневой элемент, а он уже решает, что сделать с ним - обработать самому, или передать одному из дочерних. Кстати, контейнерные элементы должны еще кое-что делать дополнительно, например запоминать, над каким из элементов последним была мышь, чтобы обеспечивать корректную обработку MouseEnter и MouseLeave.
Контейнерные элементы также могут заботиться о расположении дочерних элементов. Есть элемент FreeContainer - он не заботится ни о чём, и позволяет размещать элементы произвольно. Но другие контейнеры могут сами размещать дочерние элементы, например, в стек или в таблицу - при этом они могут лучше масштабироваться (в плане обработки ввода или рисования большого количества элементов). Есть элемент ContentContainer - он вообще имеет только один дочерний элемент - просто для делегирования ему сложностей размещения дочерних элементов.
Обработка клавиатуры основана на понятии фокуса - активного элемента, принимающего события клавиатуры. У каждого контейнерного элемента должен быть указатель на элемент в фокусе, и обработка происходит по цепочке родительских контейнеров. Элементы сами запрашивают фокус у родительского элемента. Родительский элемент при этом запрашивает фокус у своего родительского элемента, и так далее. При получении события SetFocus родительский элемент передает это событие далее своему дочернему элементу, находящемуся в фокусе.
Рисование элементов отделено от интерфейса. Элемент запрашивает рисование элементов себя у объекта Drawer.
События элементов передаются специальному объекту.