#ifndef ___INANITY_OUTPUT_STREAM_HPP___
#define ___INANITY_OUTPUT_STREAM_HPP___

#include "Object.hpp"
#include "scripting_decl.hpp"

BEGIN_INANITY

class File;
class InputStream;
template <typename T>
class Future;

/// Абстрактный класс потока вывода.
/** Предназначен для потокового вывода в различные выходные объекты.
 * Необходимо перегружать хотя бы один из методов Write.
 */
class OutputStream : public Object
{
public:
	/// Записать данные в поток.
	/** Поток обязан записывать столько данных, сколько дают.
		Если достигается конец потока (или поток по другой причине
		не может записать все данные), должно генерироваться исключение.
		Реализация по умолчанию копирует данные в файл в памяти, и вызывает
		следующий метод.
		\param data Указатель на буфер с записываемыми данными.
		\param size Размер буфера для записи, в байтах.
	*/
	virtual void Write(const void* data, size_t size) = 0;

	/// Записать данные асинхронно.
	/** Реализация по умолчанию делает это синхронно через Write. */
	virtual ptr<Future<int> > WriteAsync(ptr<File> file);

	/// Убедиться, что весь вывод записан.
	/** Поток не обязан записывать выводить данные в нужное место сразу.
		Поток имеет право буферизировать данные при записи.
		Чтобы заставить его очистить эти буферы, вызывается этот метод.
		Некоторые потоки могут разрешать вызывать этот метод только один раз,
		причём после его вызова нельзя будет вызывать Write.
		То есть вообще, лучше понимать семантику Flush, как метод-финализатор.
		Потоки-фильтры, передающие вывод в другой поток, также должны вызывать
		у него Flush, после того, как запишут в него свой вывод.
		Реализация по умолчанию ничего не делает, то есть предполагается,
		что вывод не буферизуется.
	*/
	virtual void Flush();

	/// Считать весь входной поток в себя.
	/** Так как такая задача часто встречается. */
	bigsize_t ReadAllFromStream(ptr<InputStream> inputStream);

	SCRIPTABLE_CLASS(OutputStream);
};

END_INANITY

#endif
