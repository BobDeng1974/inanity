#ifndef ___INANITY_OUTPUT_STREAM_HPP___
#define ___INANITY_OUTPUT_STREAM_HPP___

#include "Object.hpp"

BEGIN_INANITY

class InputStream;

/// Абстрактный класс потока вывода.
/** Предназначен для потокового вывода в различные выходные объекты. */
class OutputStream : public Object
{
public:
	/// Записать данные в поток.
	/** Поток обязан записывать столько данных, сколько дают.
		Если достигается конец потока (или поток по другой причине
		не может записать все данные), должно генерироваться исключение.
		\param data Указатель на буфер с записываемыми данными.
		\param size Размер буфера для записи, в байтах.
	*/
	virtual void Write(const void* data, size_t size) = 0;

	/// Убедиться, что весь вывод записан.
	/** Поток не обязан записывать выводить данные в нужное место сразу.
		Поток имеет право буферизировать данные при записи.
		Чтобы заставить его очистить эти буферы, вызывается этот метод.
		Некоторые потоки могут разрешать вызывать этот метод только один раз,
		причём после его вызова нельзя будет вызывать Write.
		То есть вообще, лучше понимать семантику Flush, как метод-финализатор.
		Потоки-фильтры, передающие вывод в другой поток, также должны вызывать
		у него Flush, после того, как запишут в него свой вывод.
		Реализация по умолчанию ничего не делает, то есть предполагается,
		что вывод не буферизуется.
	*/
	virtual void Flush();

	/// Считать весь входной поток в себя.
	/** Так как такая задача часто встречается. */
	size_t ReadAllFromStream(ptr<InputStream> inputStream);
};

END_INANITY

#endif
