Типы объектов в скрипте

1. Класс. Объект класса является единственным для данного класса, глобальным, и создаётся по соглашению с глобальным именем, соответствующим цепочке namespace'ов, например, Inanity.Graphics.System. Объект класса можно вызывать (как функцию), это олицетворяет создание объекта, то есть вызов конструктора (если он есть и scriptable). Соответственно, scriptable-конструкторов в классе не более одного. Кроме того, объект класса позволяет вызывать статические методы класса по их именам, например: Inanity.FolderFileSystem.GetNativeFileSystem(). Реализация через full userdata.
2. Объект. В C++ это ptr<SomeClass>. Объект в Lua удерживает ссылку на объект Inanity, которая снимается при сборке мусора, так что всё корректно. Объект позволяет вызывать свои методы по имени, например: someObject:someMethod(). Оператор : (или передача объекта первым параметром) обязательна. Объект наследует методы родительского класса, так что их вызывать можно тоже (при этом, если они виртуальные, то делается, естественно, виртуальный вызов). Статические методы по объекту вызывать нельзя. Объект может быть создан с помощью конструктора класса в Lua, или может быть получен из C++. Реализация через full userdata.
3. Делегат. Это сочетание объекта this и указателя на метод объекта. Для Lua делегат выглядит, как обыкновенная функция, которую можно вызывать. Реализация через функцию с this в замыкании.

Типы объектов, которые не стоит реализовывать:

1. Пространство имён (namespace) - служит для организации классов. Особый тип объектов можно было бы сделать, чтобы скрипт не мог поменять пространство имён. Но, так как скрипт всё равно может заменить весь объект Inanity, это бесполезно. Так что пусть это будут обычные таблицы.
2. Структура. В C++ это собственно структура или класс, передающаяся по значению. Могла бы быть полезной для векторов, матриц и кватернионов. Но придётся реализовывать как таблицу или full userdata, и постоянно перевыделять память при операциях, что не очень хорошо.

Планируемый объём поддержки Lua.

Передача в скрипт объектов Inanity (с объявленным SCRIPTABLE_CLASS). Переданные в скрипт объекты удерживают ссылку на себя, и позволяют вызывать SCRIPTABLE-методы обычным способом (передачей this в первом параметре, или оператором двоеточие). SCRIPTABLE-методы при вызове должны получать фиксированное количество аргументов в соответствии со своим C++-прототипом. В качестве аргументов при вызове C++-метода из скрипта поддерживаются элементарные типы (int, char, double и т.д.), строки (String), управляемые указатели (ptr<SomeClass>) и функции (как Lua, так и делегаты). Функции Lua упаковываются в специальные объекты Function. Методы объектов Inanity можно также передавать в скрипт в виде делегатов (то есть это объект+указатель на функцию). Если делегат будет возвращён обратно в C++, он также упакуется в Function. При вызове функции скрипта (через Function) можно передавать те же типы аргументов, что и для C++ методов из скрипта.

Заметим, что Function - весьма универсальный объект, так как он может хранить как указатель на функцию Lua, так и делегат C++. Тем не менее, хранить делегаты в Function не рекомендуется, просто потому, что это медленно (Function реализована через внутреннюю глобальную хеш-таблицу в состоянии скрипта), и потому, что теряется типизация (Function может вызвать функцию с любым
набором аргументов и любых типов, но делегат потом выбросит исключение, если количество или типы аргументов будут неправильными).

Ошибки, выбрасываемые Lua, превращаются в исключения Inanity. Исключения, выбрасываемые методами C++, которые вызваны из скрипта, превращаются в ошибки Lua (то есть, сами объекты Exception).

Классы Inanity, вероятно, будут лежать в специальном глобальном объекте Inanity. В нём будут подобъекты по namespace'ам.


В качестве идей:
- Перегрузка методов (определение нужного метода по количеству переданных аргументов)
- Определение конструктора(ов). Или как метод класса new, или как вызов объекта класса. Как раз для конструкторов перегрузка была бы не лишней. Сделано - единственный конструктор.
- Статические методы - сделано.
- Структуры (не ptr<Class> объекты).
- Операторы. Ничего особенного в плане вызова (они как статические методы), только регистрация в Lua как оператора. И конечно, применимо только к структурам.
- Наследование методов в соответствии с наследованием классов - сделано.
- Операторы сравнения (==, ~=) объектов и классов.
- При возврате нулевого объекта возвращается nil. Также nil допустим для возврата в качестве объекта.
- Векторы через массивы Lua.
